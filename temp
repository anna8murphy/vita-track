import json

notebook_content = {
    "cells": [
        {
            "cell_type": "code",
            "execution_count": None,
            "id": "imports_and_setup",
            "metadata": {},
            "outputs": [],
            "source": [
                "!pip install ffmpeg-python sounddevice numpy scipy matplotlib\n",
                "\n",
                "import matplotlib.pyplot as plt\n",
                "from IPython.display import HTML, Audio, clear_output\n",
                "from base64 import b64decode\n",
                "import numpy as np\n",
                "import json\n",
                "import struct\n",
                "from scipy.io.wavfile import read as wav_read\n",
                "from scipy import signal, stats\n",
                "from scipy.signal import chirp, detrend, butter, filtfilt, find_peaks\n",
                "import io\n",
                "import ffmpeg\n",
                "import sounddevice as sd\n",
                "import statistics\n",
                "import time\n",
                "from scipy.io import wavfile\n",
                "import collections # For deque"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "id": "filter_definitions",
            "metadata": {},
            "outputs": [],
            "source": [
                "def butter_lowpass(cutoff, fs, order=5):\n",
                "    nyq = 0.5 * fs\n",
                "    normalCutoff = cutoff / nyq\n",
                "    b, a = signal.butter(order, normalCutoff, btype='low')\n",
                "    return b, a\n",
                "\n",
                "def butter_lowpass_filter(data, cutoff, fs, order=5):\n",
                "    b, a = butter_lowpass(cutoff, fs, order=order)\n",
                "    y = signal.lfilter(b, a, data)\n",
                "    return y\n",
                "\n",
                "def butter_bandpass(lowcut, highcut, fs, order=5):\n",
                "    nyq = 0.5 * fs\n",
                "    low = lowcut / nyq\n",
                "    high = highcut / nyq\n",
                "    b, a = signal.butter(order, [low, high], btype='band', analog=False)\n",
                "    return b, a\n",
                "\n",
                "def butter_bandpass_filter_custom(data, lowcut, highcut, fs, order=5):\n",
                "    #This is the custom one used in the processing cell later, renamed to avoid conflict if original butter_bandpass_filter is used elsewhere\n",
                "    b, a = butter_bandpass(lowcut, highcut, fs, order=order)\n",
                "    y = signal.filtfilt(b, a, data)\n",
                "    return y\n",
                "\n",
                "def highpass(data, cutoff, fs, order=4):\n",
                "    nyq = 0.5 * fs\n",
                "    norm_cutoff = cutoff / nyq\n",
                "    b, a = butter(order, norm_cutoff, btype='high')\n",
                "    return filtfilt(b, a, data)\n",
                "\n",
                "def moving_average(x, w):\n",
                "    if len(x) < w : return x # Not enough data to average\n",
                "    return np.convolve(x, np.ones(w)/w, mode='same')"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "id": "play_and_record_chirp_def",
            "metadata": {},
            "outputs": [],
            "source": [
                "def play_and_record_chirp(freq_low,freq_high,sample_rate,chirp_duration_single,record_duration_interval,sd_device):\n",
                "    sd_device.default.channels   = 1\n",
                "    sd_device.default.samplerate = sample_rate\n",
                "\n",
                "    # Single chirp template (e.g., 0.1s)\n",
                "    chirp_t_single        = np.linspace(0, chirp_duration_single, int(sample_rate*chirp_duration_single), endpoint=False)\n",
                "    chirp_x_single        = chirp(chirp_t_single,f0=freq_low,f1=freq_high,t1=chirp_duration_single,method='linear').astype(np.float32)\n",
                "    \n",
                "    # Tile this single chirp to fill the record_duration_interval (e.g., 1s)\n",
                "    chirps_needed_for_interval = int(record_duration_interval / chirp_duration_single)\n",
                "    if chirps_needed_for_interval == 0 and record_duration_interval > 0: chirps_needed_for_interval = 1 # play at least one chirp if interval > 0\n",
                "    \n",
                "    tx_signal_for_interval = np.tile(chirp_x_single, chirps_needed_for_interval)\n",
                "    \n",
                "    # Ensure tx_signal_for_interval is not longer than record_duration_interval allows samples for\n",
                "    max_tx_samples = int(sample_rate * record_duration_interval)\n",
                "    if len(tx_signal_for_interval) > max_tx_samples:\n",
                "        tx_signal_for_interval = tx_signal_for_interval[:max_tx_samples]\n",
                "    elif len(tx_signal_for_interval) < max_tx_samples and len(tx_signal_for_interval) > 0:\n",
                "        # Pad with zeros if tx_signal is shorter than recording duration, to ensure playrec records for full duration\n",
                "        padding = np.zeros(max_tx_samples - len(tx_signal_for_interval), dtype=np.float32)\n",
                "        tx_signal_for_interval = np.concatenate((tx_signal_for_interval, padding))\n",
                "    elif len(tx_signal_for_interval) == 0 and max_tx_samples > 0:\n",
                "        tx_signal_for_interval = np.zeros(max_tx_samples, dtype=np.float32) # Play silence if no chirps fit but duration > 0\n",
                "\n",
                "\n",
                "    rx_signal_interval = sd_device.playrec(tx_signal_for_interval, samplerate=sample_rate, channels=1) # Record for the duration of tx_signal_for_interval\n",
                "    sd_device.wait() # Wait for playback and recording to finish\n",
                "\n",
                "    return tx_signal_for_interval, rx_signal_interval"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "id": "live_processing_loop",
            "metadata": {},
            "outputs": [],
            "source": [
                "# --- Parameters ---\n",
                "sample_rate = 48000\n",
                "freq_low = 17000\n",
                "freq_high = 23000\n",
                "chirp_length_single_s = 0.1  # Duration of one individual chirp\n",
                "\n",
                "window_duration_s = 15.0       # Analysis window size\n",
                "update_interval_s = 1.0        # How often to record new data and update HR\n",
                "total_experiment_duration_s = 60.0 # Total time the script will run\n",
                "\n",
                "samples_per_single_chirp = int(chirp_length_single_s * sample_rate)\n",
                "segments_per_window = int(window_duration_s / chirp_length_single_s)\n",
                "segments_per_update = int(update_interval_s / chirp_length_single_s)\n",
                "\n",
                "# Using deque for efficient buffer management (append right, pop left)\n",
                "rx_data_buffer = collections.deque(maxlen=segments_per_window)\n",
                "tx_data_buffer = collections.deque(maxlen=segments_per_window)\n",
                "\n",
                "fs_phase = 1 / chirp_length_single_s\n",
                "hr_band_low_hz = 40 / 60  # 40 BPM\n",
                "hr_band_high_hz = 210 / 60 # 210 BPM\n",
                "\n",
                "print(f\"Starting live heart rate monitoring for approx. {total_experiment_duration_s} seconds.\")\n",
                "print(f\"Analysis Window: {window_duration_s}s ({segments_per_window} segments of {chirp_length_single_s}s each)\")\n",
                "print(f\"Update Interval: {update_interval_s}s ({segments_per_update} new segments per update)\")\n",
                "print(\"-\" * 50)\n",
                "\n",
                "experiment_start_time = time.time()\n",
                "next_update_time = experiment_start_time\n",
                "\n",
                "try:\n",
                "    while (time.time() - experiment_start_time) < total_experiment_duration_s:\n",
                "        current_loop_entry_time = time.time()\n",
                "        \n",
                "        # 1. Record `update_interval_s` of new data\n",
                "        # print(f\"DEBUG: Recording {update_interval_s}s of new data...\")\n",
                "        tx_chunk_signal_arr, rx_chunk_raw_signal_arr = play_and_record_chirp(\n",
                "            freq_low, freq_high, sample_rate,\n",
                "            chirp_length_single_s,      # chirp_duration_single\n",
                "            update_interval_s,          # record_duration_interval for this call\n",
                "            sd                          # sounddevice object\n",
                "        )\n",
                "        # print(f\"DEBUG: Recording for this interval done. rx_chunk_raw_signal_arr shape: {rx_chunk_raw_signal_arr.shape}\")\n",
                "\n",
                "        rx_chunk_mono_arr = rx_chunk_raw_signal_arr[:, 0]\n",
                "\n",
                "        num_actually_recorded_segments = len(rx_chunk_mono_arr) // samples_per_single_chirp\n",
                "\n",
                "        if num_actually_recorded_segments > 0:\n",
                "            rx_chunk_trimmed_arr = rx_chunk_mono_arr[:num_actually_recorded_segments * samples_per_single_chirp]\n",
                "            rx_new_segments_list_of_arrays = np.split(rx_chunk_trimmed_arr, num_actually_recorded_segments)\n",
                "            \n",
                "            tx_chirp_template_arr = chirp(np.linspace(0, chirp_length_single_s, samples_per_single_chirp, endpoint=False), f0=freq_low, f1=freq_high, t1=chirp_length_single_s, method='linear').astype(np.float32)\n",
                "            tx_new_segments_list_of_arrays = [tx_chirp_template_arr for _ in range(num_actually_recorded_segments)]\n",
                "\n",
                "            rx_data_buffer.extend(rx_new_segments_list_of_arrays)\n",
                "            tx_data_buffer.extend(tx_new_segments_list_of_arrays)\n",
                "        else:\n",
                "            print(f\"[{time.time() - experiment_start_time:.1f}s] Warning: No full new segments recorded in this interval.\")\n",
                "            # Optional: wait to maintain rhythm if recording yields nothing\n",
                "            time.sleep(max(0, update_interval_s - (time.time() - current_loop_entry_time)))\n",
                "            continue\n",
                "\n",
                "        # 2. Check if buffer has enough data for a full window\n",
                "        if len(rx_data_buffer) == segments_per_window:\n",
                "            rx_window_arr = np.array(list(rx_data_buffer))\n",
                "            tx_window_arr = np.array(list(tx_data_buffer))\n",
                "\n",
                "            # --- Dechirp ---\n",
                "            dechirped_window_arr = rx_window_arr * np.conj(tx_window_arr)\n",
                "            \n",
                "            # --- FFT of Dechirped Signal ---\n",
                "            fft_data_window_arr = np.fft.fft(dechirped_window_arr, n=samples_per_single_chirp, axis=1)\n",
                "            \n",
                "            mean_fft_abs_arr = np.mean(np.abs(fft_data_window_arr), axis=0)\n",
                "            if np.all(mean_fft_abs_arr < 1e-9):\n",
                "                print(f\"[{time.time() - experiment_start_time:.1f}s] Low signal energy in window.\")\n",
                "                bpm_from_peaks_val, bpm_from_fft_val = None, None\n",
                "            else:\n",
                "                bin_to_track_idx = np.argmax(mean_fft_abs_arr)\n",
                "                phases_window_arr = np.angle(fft_data_window_arr[:, bin_to_track_idx])\n",
                "                unwrapped_phases_window_arr = np.unwrap(phases_window_arr)\n",
                "                detrended_phase_window_arr = detrend(unwrapped_phases_window_arr)\n",
                "\n",
                "                times_relative_window_arr = np.arange(len(unwrapped_phases_window_arr)) * chirp_length_single_s\n",
                "\n",
                "                hr_filtered_window_arr = butter_bandpass_filter_custom(detrended_phase_window_arr, hr_band_low_hz, hr_band_high_hz, fs_phase, order=3)\n",
                "\n",
                "                smoothing_w_val = 5 \n",
                "                smoothed_window_arr = moving_average(hr_filtered_window_arr, w=smoothing_w_val)\n",
                "\n",
                "                min_peak_dist_samples_val = max(1, int(fs_phase / (hr_band_high_hz * 1.1)))\n",
                "                peaks_indices, _ = find_peaks(smoothed_window_arr, height=np.std(smoothed_window_arr)*0.1 if np.std(smoothed_window_arr) > 1e-6 else 0.0001, distance=min_peak_dist_samples_val)\n",
                "\n",
                "                bpm_from_peaks_val = None\n",
                "                if len(peaks_indices) > 2:\n",
                "                    intervals_s_arr = np.diff(times_relative_window_arr[peaks_indices])\n",
                "                    if len(intervals_s_arr) > 0:\n",
                "                        median_interval_s = statistics.median(intervals_s_arr)\n",
                "                        if median_interval_s > 1e-6: bpm_from_peaks_val = 60 / median_interval_s\n",
                "                \n",
                "                hr_fft_output_arr = np.fft.rfft(hr_filtered_window_arr)\n",
                "                hr_freqs_fft_hz_arr = np.fft.rfftfreq(len(hr_filtered_window_arr), d=chirp_length_single_s)\n",
                "                hr_bpm_freqs_fft_arr = hr_freqs_fft_hz_arr * 60\n",
                "\n",
                "                fft_mask_arr = (hr_bpm_freqs_fft_arr >= (hr_band_low_hz*60)) & (hr_bpm_freqs_fft_arr <= (hr_band_high_hz*60))\n",
                "                hr_bpm_freqs_masked_arr = hr_bpm_freqs_fft_arr[fft_mask_arr]\n",
                "                hr_fft_mag_masked_arr = np.abs(hr_fft_output_arr)[fft_mask_arr]\n",
                "\n",
                "                bpm_from_fft_val = None\n",
                "                if len(hr_fft_mag_masked_arr) > 0:\n",
                "                    peak_idx_fft_masked = np.argmax(hr_fft_mag_masked_arr)\n",
                "                    bpm_from_fft_val = hr_bpm_freqs_masked_arr[peak_idx_fft_masked]\n",
                "\n",
                "            # --- Print results ---\n",
                "            clear_output(wait=True) # Clears the output of the cell to show only the latest HR\n",
                "            print(f\"--- Heart Rate at ~{time.time() - experiment_start_time:.1f}s ---\")\n",
                "            if bpm_from_peaks_val is not None: print(f\"    Peak Intervals: {bpm_from_peaks_val:.2f} BPM\")\n",
                "            else: print(\"    Peak Intervals: N/A\")\n",
                "            if bpm_from_fft_val is not None: print(f\"    FFT: {bpm_from_fft_val:.2f} BPM\")\n",
                "            else: print(\"    FFT: N/A\")\n",
                "        else:\n",
                "            clear_output(wait=True)\n",
                "            print(f\"[{time.time() - experiment_start_time:.1f}s] Accumulating data... ({len(rx_data_buffer) * chirp_length_single_s:.1f}s / {window_duration_s}s for first window)\")\n",
                "\n",
                "        # Maintain update interval approximately\n",
                "        processing_time_this_iteration = time.time() - current_loop_entry_time\n",
                "        sleep_time = max(0, update_interval_s - processing_time_this_iteration)\n",
                "        if sleep_time > 0:\n",
                "            time.sleep(sleep_time)\n",
                "except KeyboardInterrupt:\n",
                "    print(\"\\nMonitoring stopped by user.\")\n",
                "finally:\n",
                "    print(\"\\nLive monitoring finished.\")\n"
            ]
        }
    ],
    "metadata": {
        "kernelspec": {
            "display_name": "Python 3 (ipykernel)", # Or your specific kernel name
            "language": "python",
            "name": "python3" # Or your specific kernel name
        },
        "language_info": {
            "codemirror_mode": {
                "name": "ipython",
                "version": 3
            },
            "file_extension": ".py",
            "mimetype": "text/x-python",
            "name": "python",
            "nbconvert_exporter": "python",
            "pygments_lexer": "ipython3",
            "version": "3.9.12"  # Example, adjust to your Python version if known
        }
    },
    "nbformat": 4,
    "nbformat_minor": 5
}

# Write the notebook content to a .ipynb file
file_path = "HR_analysis_live.ipynb"
with open(file_path, "w") as f:
    json.dump(notebook_content, f, indent=2)

print(f"Notebook '{file_path}' created successfully.")
print("You can now open it with Jupyter Notebook, JupyterLab, or VS Code.")

